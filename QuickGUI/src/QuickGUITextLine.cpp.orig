#include "QuickGUITextLine.h"
#include "QuickGUIText.h"

namespace QuickGUI
{
	TextLine::TextLine()
	{
		mLargestFont.setNull();
		mMaskText = false;
	}

	TextLine::~TextLine()
	{
	}

	void TextLine::_verticallyAlignCharacters()
	{
		Ogre::TexturePtr largestFontTexture = Text::getFontTexture(mLargestFont);
		float maxBaseLine = static_cast<float>(mLargestFont->getTrueTypeMaxBearingY());

		for(std::vector<Character*>::iterator it = mCharacters.begin(); it != mCharacters.end(); ++it)
		{
			Ogre::TexturePtr tp = Text::getFontTexture((*it)->fontPtr);
			float baseLine = static_cast<float>((*it)->fontPtr->getTrueTypeMaxBearingY());

			(*it)->dimensions.position.y = maxBaseLine - baseLine;
			(*it)->dimensions.position.roundUp();
		}
	}

	void TextLine::addCharacter(Character* c)
	{
		float baseline = 0;
		if(!mCharacters.empty())
		{
			Character* lastChar = mCharacters.back();
			baseline = lastChar->getBaseline() + lastChar->getAdvance();
		}
		
		c->setBaseline(baseline);
		mCharacters.push_back(c);


		if(mLargestFont.isNull() || Text::getFontHeight(c->fontPtr) > Text::getFontHeight(mLargestFont))
		{
			mLargestFont = c->fontPtr;
			_verticallyAlignCharacters();
		}
		else
		{
			float maxBaseLine = static_cast<float>(mLargestFont->getTrueTypeMaxBearingY());
			float baseLine = static_cast<float>(c->fontPtr->getTrueTypeMaxBearingY());
			c->dimensions.position.y = maxBaseLine - baseLine;
		}

		c->dimensions.position.roundUp();
	}

	void TextLine::draw(Point p)
	{
		mPosition = p;
		mPosition.roundUp();
		Brush* brush = Brush::getSingletonPtr();
		Ogre::String currentTexture = "TextSelection";

		// Render any quads queued for drawing.
		brush->endRectQueue();

		// Do an initial pass to draw any quads related to text highlighting
		brush->setTexture("TextSelection");

		brush->beginRectQueue();

		for(std::vector<Character*>::iterator it = mCharacters.begin(); it != mCharacters.end(); ++it)
		{
			// Ignore any newline characters
			if(Text::isNewLine((*it)->codePoint) || Text::isNullCharacter((*it)->codePoint))
				continue;

			if((*it)->getHighlighted())
			{
				brush->setColor((*it)->getHighlightColor());
				brush->queueRect(Rect((*it)->dimensions.position + mPosition,(*it)->dimensions.size),(*it)->uvCoords);
			}
		}

		// Do a second pass and render the glyphs

		// If the text is masked, we just need to render the mask Symbol.  We will render using the largest font
		if(mMaskText)
		{
			// Render any currently queued quads
			brush->endRectQueue();

			// Set texture to largest font's texture
			Ogre::TexturePtr texturePtr = Text::getFontTexture(mLargestFont);
			brush->setTexture(texturePtr);
			if(!mCharacters.empty())
				brush->setColor(mCharacters.front()->colorValue);

			brush->beginRectQueue();

			// Get the glyph's UV Coords
			UVRect uvCoords = Text::getGlyphUVCoords(mLargestFont,mMaskSymbol);
			// Use UV Coords to Determine character dimensions
            Size s = Text::getGlyphSize(mLargestFont,mMaskSymbol);
			float maskBearing = Text::getGlyphBearing(mLargestFont,mMaskSymbol);

			for(std::vector<Character*>::iterator it = mCharacters.begin(); it != mCharacters.end(); ++it)
			{
				Character* character = (*it);
				if(Text::isNewLine(character->codePoint) || Text::isNullCharacter(character->codePoint))
					continue;

				Point glyphPosition(character->getBaseline() + maskBearing, character->dimensions.position.y);
				glyphPosition.roundUp();
				brush->queueRect(Rect(glyphPosition + mPosition,s),uvCoords);
			}
		}
		else
		{
			for(std::vector<Character*>::iterator it = mCharacters.begin(); it != mCharacters.end(); ++it)
			{
				if((*it)->isWhiteSpace())
					continue;

				if( currentTexture != (*it)->texturePtr->getName() )
				{
					brush->endRectQueue();

					currentTexture = (*it)->texturePtr->getName();
					brush->setTexture(currentTexture);

					brush->beginRectQueue();
				}

				if((*it)->getHighlighted())
					brush->setColor((*it)->getHighlightedTextColor());
				else
					brush->setColor((*it)->colorValue);

				brush->queueRect(Rect((*it)->dimensions.position + mPosition,(*it)->dimensions.size),(*it)->uvCoords);
			}
		}
	}

	bool TextLine::empty()
	{
		return mCharacters.empty();
	}

	Character* TextLine::getCharacter(int index)
	{
		if(mCharacters.empty())
			return NULL;

		if(index < 0)
			index = 0;
		else if(index >= static_cast<int>(mCharacters.size()))
			index = static_cast<int>(mCharacters.size()) - 1;

		return mCharacters[index];
	}

	int TextLine::getCursorIndexAtPosition(Point p)
	{
		if(mCharacters.empty())
			return 0;

 		int index = 0;
		float previousBaseline = 0;
		float previousAdvance = 0;
		bool havePrevious = false;

		for(std::vector<Character*>::iterator it = mCharacters.begin(); it != mCharacters.end(); ++it)
		{
			Character* character = (*it);
			if(Text::isNewLine(character->codePoint) || Text::isNullCharacter(character->codePoint))
				break;

			float baseline = character->getBaseline();

			if(p.x < baseline)
			{
				if(havePrevious)
				{
					float midpoint = previousBaseline + (previousAdvance * 0.5f);
					if(p.x < midpoint)
						return index - 1;
				}

				return index;
			}
		
			previousBaseline = baseline;
			previousAdvance = character->getAdvance();
			havePrevious = true;
			++index;
		}
		
		if(havePrevious)
		{
			float midpoint = previousBaseline + (previousAdvance * 0.5f);
			if(p.x < midpoint)
				return (index - 1 < 0) ? 0 : index - 1;
 		}
 		
 		return (index > 0) ? index - 1 : 0;
	}

	float TextLine::getHeight()
	{
		if(mLargestFont.isNull())
			return 0;

		return Text::getFontHeight(mLargestFont);
	}

	int TextLine::getLength()
	{
		return static_cast<int>(mCharacters.size());
	}

	Point TextLine::getPositionAtCharacterIndex(unsigned int index)
	{
		// Force index to be valid for all values given
		if(index >= static_cast<unsigned int>(mCharacters.size()))
			index = static_cast<unsigned int>(mCharacters.size()) - 1;

		Point p;

		if(mMaskText)
		{
			p.x = mCharacters[index]->getBaseline();
		}
		else
		{
			p.x = mCharacters[index]->dimensions.position.x;
		}

		return p;
	}

	float TextLine::getWidth()
	{
		Character* firstCharacter = NULL;
		Character* lastCharacter = NULL;

		for(std::vector<Character*>::iterator it = mCharacters.begin(); it != mCharacters.end(); ++it)
		{
			Character* character = (*it);
			if(Text::isNewLine(character->codePoint) || Text::isNullCharacter(character->codePoint))
				continue;

			if(firstCharacter == NULL)
				firstCharacter = character;
			
		lastCharacter = character;

		if(firstCharacter == NULL || lastCharacter == NULL)
			return 0;

		return (lastCharacter->getBaseline() + lastCharacter->getAdvance()) - firstCharacter->getBaseline();
	}

	void TextLine::setMaskText(bool mask, Ogre::UTFString::code_point maskSymbol)
	{
		mMaskText = mask;
		mMaskSymbol = maskSymbol;
	}
}
